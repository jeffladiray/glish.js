<html>
  <head>
    <style>

    .biome {
      width: 16px;
      height: 16px;
      margin:0;
      padding: 0;
      border: none;
      outline: none;
      display: inline-block;
    }

    .spawnable {
      width: 16px;
      height: 16px;
      margin:0;
      padding: 0;
      border: none;
      outline: none;
      display: inline-block;
    }

    img {
      display: -moz-inline-box;
      -moz-box-orient: vertical;
      display: inline-block;
      *display: inline;
      vertical-align: middle;
      vertical-align: auto;
      font: 0/0 serif;
      text-shadow: none;
      color: transparent;
      background-size: contain;
      background-position: 50% 50%;
      background-repeat: no-repeat;
      box-sizing: border-box;
    }
    </style>
  </head>
  <body>
    <p id="cellDetails"></p>
    <script type="text/javascript">


      window.fetch('/map').then((response) => {
        return response.json();
      })
      .then((data) => {
        var style = document.createElement('style');
        let biomeInterfaces = [];
        for (let i = 0; i < data.biomes.length; i++) {
          biomeInterfaces.push(`${(data.biomes[i] || {}).type}${(data.biomes[i + 1] || {}).type}`);
        }
        style.type = 'text/css';
        biomeInterfaces.forEach((biomeInterface, k) => {
          for(let i = 0; i < 5; i++) {
            for(let j = 0; j < 4; j++) {
              style.innerHTML += `.${biomeInterface}${i}-${j} {
                background: url('/s2.png') -${k * 5 * 16 + i * 16}px -${j * 16}px;
              }\n`;
            }
          }
        });
        
        data.spawnables.forEach((s) => {
          style.innerHTML += `.${s.type} {
                background: url('/s3.png') -${s.resource.position.x * 16}px -${s.resource.position.y * 16}px;
              }\n`;
        })


        document.head.appendChild(style);
        const map = document.createElement('div');
        console.warn(data);
        const getCardinalWithBiomeName = (bc, neighbours) => {
          return neighbours
          .filter(n => n.biome !== bc.biome.type)
          .reduce((acc, n) => {
            return acc += n.position;
          }, '');
        }

        const getXYFromNeighbours = (cell) => {
          const nghs = cell.content.biome.neighbours;
          if (nghs) {
            const card = nghs.sort((n1, n2) => n1.position.length < n2.position.length).reduce((acc, v) => {
              return !acc.includes(v.position) ? acc += v.position : acc;
            }, '').replace(/[\s\S](?=([\s\S]+))/g, function(c, s) {
              return s.indexOf(c) + 1 ? '' : c;
            });;
            if (nghs.length === 0)Â {
              return { x: 1, y: 0 };
            } else if (nghs.length === 1) {
              if (card.match(/[N|W]{2}/)) { return { x: 3, y: 2 }; }
                else if (card.match(/[N|E]{2}/)) { return { x: 4, y: 2 }; }
                else if (card.match(/[S|W]{2}/)) { return { x: 3, y: 3 }; }
                else if (card.match(/[S|E]{2}/)) { return  { x: 4, y: 3 }; }
                else if (card.includes('N')) { return { x: 1, y: 1 }; }
                else if (card.includes('S')) { return { x: 1, y: 3 }; }
                else if (card.includes('W')) { return  { x: 0, y: 2 };}
                else if (card.includes('E')) { return { x: 2, y: 2 }; }
            } else if (nghs.length === 2) {
              const dominant = nghs.find(n => n.position.length === 1);
              if(dominant) {
                const d = dominant.position;
                if (d.includes('N')) { return { x: 1, y: 1 }; }
                else if (d.includes('S')) { return { x: 1, y: 3 }; }
                else if (d.includes('W')) { return { x: 0, y: 2 }; }
                else if (d.includes('E')) { return  { x: 2, y: 2 };}
              }
            } else if (nghs.length === 3) {
              if (card.length > 2) {
                // Line shape
                if (!card.includes('N')) { return { x: 1, y: 3 }; }
                else if (!card.includes('S')) { return { x: 1, y: 1 }; }
                else if (!card.includes('W')) { return  { x: 2, y: 2 };}
                else if (!card.includes('E')) { return { x: 0, y: 2 }; }
              } else {
                // Angle shape
                if (card.match(/[NW]{2}/)) { return { x: 0, y: 1 }; }
                else if (card.match(/[NE]{2}/)) { return { x: 2, y: 1 }; }
                else if (card.match(/[SW]{2}/)) { return { x: 0, y: 3 }; }
                else if (card.match(/[SE]{2}/)) { return { x: 2, y: 3 }; }
                else { return { x: 1, y: 0 }; }
              }
            } else if (nghs.length >= 4 && nghs.length < 6) {
              // L Shape
              const dominants = nghs.filter(n => n.position.length === 1);
              if(dominants) {
                const ds = dominants.map(d => d.position).join('');
                if(nghs.length === 5) {
                    if (ds.match(/[NS]{2}/)) { return { x: 3, y: 1 }; }
                    else if (ds.match(/[EW]{2}/)) { return { x: 3, y: 0 }; }
                }
                if (ds.match(/[NW]{2}/)) { return { x: 0, y: 1 }; }
                else if (ds.match(/[NE]{2}/)) { return { x: 2, y: 1 }; }
                else if (ds.match(/[SW]{2}/)) { return { x: 0, y: 3 }; }
                else if (ds.match(/[SE]{2}/)) { return  { x: 2, y: 3 }; }
              }
            } else if(nghs.length > 5) {
              return { x: 0, y: 0 };
            }
            return { x: 1, y: 0 };
          }
        };

        const getClassName = (from, to, xy) => {
          if(from === "OCEAN_BIOME" && to === "BEACH_BIOME") {
            return `biome OCEAN_BIOMEBEACH_BIOME${xy.x}-${xy.y}`;
          } else if(from === "BEACH_BIOME" && to === "GRASS_BIOME") {
            return `biome BEACH_BIOMEGRASS_BIOME${xy.x}-${xy.y}`;
          } else if(from === "GRASS_BIOME" && to === "MOUNTAIN_BIOME") {
            return `biome GRASS_BIOMEMOUNTAIN_BIOME${xy.x}-${xy.y}`;
          } else if (from === 'OCEAN_BIOME') {
            from = 'biome OCEAN_BIOMEBEACH_BIOME1-0';
          } else if (from === 'BEACH_BIOME') {
            from = 'biome BEACH_BIOMEGRASS_BIOME1-0';
          } else if (from === 'GRASS_BIOME') {
            from = 'biome GRASS_BIOMEMOUNTAIN_BIOME1-0';
          } else if (from === 'MOUNTAIN_BIOME') {
            from = 'biome GRASS_BIOMEMOUNTAIN_BIOME2-0';
          }
          return from;
        };

        data.map.matrix.forEach((row, i) => {
          const r = document.createElement('div');
          map.appendChild(r);
          row.forEach((cell, j) => {

            const c = document.createElement('div');
            c.onclick = () => {
              document.getElementById('cellDetails').innerHTML = JSON.stringify(cell);
            }
            c.className = getClassName(cell.content.biome.type,'', '');
            const isInBorder = data.borders.find((bd) => {
              return bd.find((e) => e.id === cell.id);
            });

            if(cell.content.biome.neighbours && cell.content.biome.neighbours.length > 0 && isInBorder) {
              const to = cell.content.biome.neighbours.filter(p => p.biome !== cell.content.biome.type)[0];
              if(to) c.className = `${getClassName(cell.content.biome.type, to.biome, getXYFromNeighbours(cell))}`;
            }

            if(cell.content.item) {
              const w = document.createElement('div');
              let ca = `spawnable ${cell.content.item.type}`;
              w.className = ca;
              c.appendChild(w); 
            }

            r.appendChild(c); 
            
          });
        });
        document.body.appendChild(map);
      }).catch((err) => {
        console.log(err);
      });
    </script>
  </body>
</html>

